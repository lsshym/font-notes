## 说实话，我在前端没怎么用过继承

主要还是通过原型链是思想，毕竟继承说白了还是为了复用，感觉是从别的语言里学过来的思想，我当时Java学的还行讲道理，嘿，创建一个抽象类，或者说他爹，给子类创建一些默认的东西，简单的说这就是继承

#### 这里只记录几个需要注意的问题，别的一些东西太简单了没记

####  原型链存在两个问题，一个是引用类型的值会公用

```javascript
function Father(){
	this.array = [1,2,3,4];
    this.test1 = 'test';
    this.test2 = {
        a: 1
    }
}

function Son(){
}
//继承 Father
// 这里没办法给Son传递参数
Son.prototype = new Father();//Son.prototype被重写,导致Son.prototype.constructor也一同被重写

var son1 = new Son();
var son2 = new Son();
son1.array.push(5);
son1.test = '666';
son1.test2.a = 2;
console.log(son1);
console.log(son2);
```

有点意思，刚发现，如果是基础类型的值，不会参与原型链的查找，直接增加

#### 接用构造函数（经典继承）

```javascript
function Father(name) {
    this.name = name
}
function Childern() {
    Father.call(this, '666')
}
// 缺点就是，调用不到，所有的方法都要写在Father
Father.prototype.say = function() {
    console.log('hello')
}
// 两个实例对象互不干扰

var son1 = new Childern();
var son2 = new Childern();
son1.say()

```

#### 原型式继承

没必要大费周章的使用构造函数，这就是构造函数继承和组合继承的弊病（并不懂），只不过原型式继承的缺点是会共享